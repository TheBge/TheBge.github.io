title: 错题本
author: Bing
tags: []
categories: []
date: 2021-03-02 21:16:00
---
1.
```c++
void Func(char str_arg[100])
{
       printf("%d\n",sizeof(str_arg));
}
int main(void)
{
     char str[]="Hello";
     printf("%d\n",sizeof(str));
    printf("%d\n",strlen(str));
    char*p=str;
    printf("%d\n",sizeof(p));
    Func(str);
}
```
输出结果为：6 5 4 4
对字符串进行sizeof操作的时候，会把字符串的结束符"\0"计算进去的，进行strlen操作求字符串的长度的时候，不计算\0的。
数组作为函数参数传递的时候，已经退化为指针了，Func函数的参数str_arg只是表示一个指针，100不起任何作用的。
c++中不允许隐式的数组拷贝，所以Func的参数会被隐式地转为char*,若Func的原型为void Func(char (&str_arg)[6])（若不为6则调用出错），则结果为6.  

2.
```c++
C c;
void main()
{
    A*pa=new A();
    B b;
    static D d;
    delete pa;
}
```
全局变量和静态局部变量时从静态存储区中划分的空间，
二者的区别在于作用域的不同，全局变量作用域大于静态局部变量（只用于声明它的函数中），
而之所以是先释放 D 在释放 C的原因是， 程序中首先调用的是 C的构造函数，然后调用的是 D 的构造函数，析构函数的调用与构造函数的调用顺序刚好相反。  
局部变量A 是通过 new 从系统的堆空间中分配的，程序运行结束之后，系统是不会自动回收分配给它的空间的，需要程序员手动调用 delete 来释放。  
局部变量 B 对象的空间来自于系统的栈空间，在该方法执行结束就会由系统自动通过调用析构方法将其空间释放。  
之所以是 先 A  后 B 是因为，B 是在函数执行到 结尾 "}" 的时候才调用析构函数， 而语句 delete a ; 位于函数结尾 "}" 之前。  

3.
在类中，如果什么都没有，则类占用1个字节，一旦类中有其他的占用空间成员，则这1个字节就不在计算之内，如一个类只有一个int则占用4字节而不是5字节。  
如果只有成员函数，则还是只占用1个字节，因为类函数不占用空间  
虚函数因为存在一个虚函数表，需要4个字节，数据成员对象如果为指针则为4字节，注意有字节对齐，如果为13字节，则进位到16字节空间。  

4.
父类指针指向子类实例对象，调用普通重写方法时，会调用父类中的方法。而调用被子类重写虚函数时，会调用子类中的方法。  
再次说明了，子类中被重写的虚函数的运行方式是动态绑定的，与当前指向类实例的父类指针类型无关，仅和类实例对象本身有关。  

5.
```c++
#include<iostream>
using namespace std;
class MyClass
{
public:
    MyClass(int i = 0)
    {
        cout << i;
    }
    MyClass(const MyClass &x)
    {
        cout << 2;
    }
    MyClass &operator=(const MyClass &x)
    {
        cout << 3;
        return *this;
    }
    ~MyClass()
    {
        cout << 4;
    }
};
int main()
{
    MyClass obj1(1), obj2(2);
    MyClass obj3 = obj1;
    return 0;
}
```
拷贝构造函数发生在对象还没有创建，需要创建时，如obj3；赋值操作符重载仅发生在对象已经执行过构造函数，即已经创建的情况下。
前两个对象构造时分别输出1,2  
第三个对象是这样构造的MyClass obj3 = obj1，之前没有执行过构造函数创建对象，所以这里会调用拷贝构造函数，输出2  
然后三个对象依次析构，输出444  
所以最终输出122444  

6.

