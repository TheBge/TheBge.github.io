title: 类型转换
author: Bing
tags:
  - C++
categories:
  - C++
date: 2020-11-12 14:13:00
---
### const_cast  

const修饰函数返回值表示返回值不可改变,多用于返回指针的情形  

1、常量指针被转化成非常量的指针，并且仍然指向原来的对象；   
2、常量引用被转换成非常量的引用，并且仍然指向原来的对象；   
3、const_cast一般用于修改指针。如const char *p形式；  

```c
const int a = 233;
int &b = const_cast<int&>(a); //去const引用
int *c = const_cast<int*>(&a); //去const指针
```

### static_cast 

1、static_cast 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。  
2、用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行**上行转换**（把派生类的指针或引用转换成基类表示）是安全的；进行**下行转换**（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。
**转换自定义类型，只有在相互联系（继承）的类型之间才能进行转换**。  

### dynamic_cast  

1、其他三种都是编译时完成的。dynamic_cast是运行时处理的，运行时要进行类型检查。  
2、不能用于内置基本数据类型间的强制转换。例如：  
```c
double dValue = 12.12;
int nDValue = dynamic_cast<int>(dValue); // error C2680 : “int” : dynamic_cast 的目标类型无效。目标类型必须是指向已定义类的指针或引用
```
3、使用dynamic_cast进行转换时，基类中一定要有虚函数，否则编译不通过。

原因：类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的必要，此时转换才有意义。
由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表。  
4、dynamic_cast转换若成功，返回的是指向类的指针或引用；若失败则会返回NULL。

5、在类的转换时，在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的。
在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。  
向上转换即为指向子类对象的向上转换，即将子类指针转化父类指针。
向下转换的成败取决于将要转换的类型，即要强制转换的指针所指向的对象实际类型与将要转换后的类型一定要相同，否则转换失败。  

### reinterpret_cast
emmmmmm.....没用过