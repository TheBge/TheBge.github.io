title: 理解多态
author: Bing
tags:
  - C++
categories:
  - C++
date: 2020-12-29 14:48:00
---
```c
A* P=new B; //A是父类,B是子类

虽然P是一个基类的指针。但是new B调用的是派生类B的构造方法，所以构造的是B类对象。先调用A的构造函数，再调用B的构造函数。构造完后会返回B类对象的地址，然后将它赋给一个基类指针P。
```

```c
B* q=new B;//这里和上面唯一的区别就是，将B类对象的地址赋给了派生类指针q
```

   而需要注意的是：可以将一个派生类对象的地址赋给基类指针和派生类指针，而一个基类对象的地址只能赋给基类指针，不能赋给派生类的指针。因为派生类不但拥有基类的方法属性，还有基类没有的属性方法。

   将一个地址赋给一个指针前，通常会将该地址处的对象类型转换为指针所指的类型。而将一个基类地址赋给一个派生类指针是不允许的，如果可以的话，那么这个指针就可以调用派生类的方法和属性。但指针指向的是一个基类对象，而基类可能并没有这些方法和属性，因为这些方法和属性是派生类新增的，所以，基类地址赋给一个派生类指针是不允许的。但将一个派生类对象的地址赋给一个基类指针是可以的，因为，基类指针能调用的方法和属性，派生类都有，所以并不会有什么问题。